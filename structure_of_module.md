# Array Parser

## 프로그램 설계
---

### 1. 토큰 순환 처리

작업 | 담당 메서드
---|---
문자열 형태 배열을 받아, 각각의 문자(토큰)들을 반복해서 자료 처리 메서드에 입력 | arrLexer.lexer
비슷한 유형의 토큰들이 같은 프로세스를 통과하도록 tokenType을 지정 | arrLexer.tagTokenType

### 2. 토큰 처리 과정

작업 | 담당 메서드
---|---
배열의 시작을 알리는 토큰 '['을 받아 새 자료구조를 dataBranchQueue에 추가한다. | rules.charProcessing.array['[']
숫자타입 자료 토큰이 입력되면 임시 저장소 arrLexer.tempMemory에 저장한다. 저장소가 비어있다면 새 자료구조로서, 비어있지 않다면 기존 자료구조의 값을 갱신한다. | rules.charProcessing.array['number']
요소의 입력이 끝났음을 알리는 토큰 ','이 입력되면, → 임시 저장소에 있던 자료구조를 가져오고, 해당 저장소는 비운다 → 가져온 자료구조의 value 속성을 type 속성에 맞게 변환하고 → 요소를 추가중인 배열 자료구조에 자녀 요소로서 입력한다. | rules.charProcessing.array['appendElem']
2와 3을 반복한다. | 
배열의 종료를 알리는 토큰 ']'이 입력되면 → 3번의 임시 저장 자료구조 추가 동작을 수행하고 → 현재 작업중인 자료구조를 dataBranchQueue에서 빼낸 뒤 → 임시 저장소 arrLexer.tempMemory에 저장한다. | rules.charProcessing.array[']']
만약 2번 동작 중에 새로운 '[' 토큰이 입력되면, 1번 동작부터 반복해 자녀 배열을 추가한다. | rules.charProcessing.array['[']

### 3. 어휘 처리

1. 문자열
  * 따옴표 (', ", `) 토큰이 입력되면 스택과 메모리에 문자열 오브젝트를 추가
  * 이후 입력되는 모든 문자를 문자열로서 오브젝트의 값(value 속성의 값)으로 추가
  * 문자열이 시작되면, 기존에 토큰을 처리할 때 사용하던 특수문자들(따옴표, 괄호, 쉼표) 또한 일반 문자열로서 처리한다
  * 새로운 따옴표가 입력되면 문자열 오브젝트를 스택에서 제거한다. 메모리에 있는 문자열 오브젝트는 향후 요소 입력 토큰(',')이 처리한다
  * 요소 입력 토큰이 입력되기 전에 새로이 따옴표 토큰이 입력되면, 문자열 내 중복 따옴표가 존재하는 것으로 판단하고 오류문자열(errorString) 자료형을 부여한다.
  * 해당 오류문자열이 메모리에 있을 때, 요소 입력 토큰이 자료를 처리하며 '올바른 문자열이 아님' 오류를 출력한다

2. 명령어 키워드 (null, boolean)
  * 입력중인 문자열이 메모리에 존재하지 않을 때 새로 문자열이 입력되면, 명령어의 시작으로 보고 명령어 오브젝트를 스택과 메모리에 추가한다
  * 요소 입력 토큰(',')이 입력되기 전 까지 문자열을 받아 명령어 어휘로 저장한다
  * 요소 입력 토큰이 어휘를 처리할 때 저장된 어휘 사전을 검색해 알맞은 타입(boolean, object)과 값을 배정한다
  * 해당 어휘가 사전에 없으면 '존재하지 않는 명령어' 오류를 출력한다

3. 숫자열 오류 처리
  * 숫자열 입력 도중 문자열 및 공백문자가 입력될 경우, 요소 입력 토큰이 값을 처리할 때 '알 수 없는 타입' 오류를 출력한다

4. 객체
  * 입력 개시: 여는 괄호('{')가 입력되면 스택에 '객체' 자료형 객체를 추가
  * 키값 입력
    - 이후 키값이 기존 메서드를 통해 숫자/문자열/키워드 형태로 메모리에 저장된다.
    - 키값이 완료된 후 키 입력 완료 토큰(':')이 뒤따라 입력되면, 메모리에 저장한 자료에 'objectProperty' 타입을 새로 부여하고 스택에 저장한다.
  * 속성 입력
    - 이후 속성의 값이 기존 메서드를 통해 숫자/문자열/키워드 형태로 메모리에 저장된다.
    - 스택에 'objectProperty' 객체가 있을 때 요소 입력 토큰(',')이 입력되면, appendKeyValPair 메서드를 통해 메모리에 저장된 자료를 objectProperty 객체에 속성값('propVal') 으로서 첨부한다
    - 이후 위 속성 객체를 부모 객체의 child 배열에 덧붙인다.
  * 입력 종료: 닫는 괄호('}')가 입력되면,
    - 메모리에 남아있는 속성 객체를 부모 객체에 입력하고
    - 현재 스택에 있는 객체 어휘를 향후 처리를 위해 메모리에 저장하고 다음 토큰으로 이동한다

### 4. 생성된 자료구조 출력

작업 | 담당 메서드
---|---
2번 과정을 통해 해당 배열의 자료구조가 arrLexer.tempMemory에 저장되어 있다. | 
임시 메모리에 있는 자료구조를 통합 자료구조 저장소 arrLexer.dataTree로 저장하고 tempMemory는 비운다.| 
추가로 처리할 객체가 없으므로 dataTree 안의 자료구조를 반환하고, dataTree를 비운다.| arrLexer.lexer


### 5. *** (NEW) 오류 기록 ***
  1. 짝이 맞지 않는 객체/배열
    * 객체를 닫기 전 / 문자열이 끝날 때 rules.checkUnclosedObject 메서드를 호출
    * 아래 오류사항이 발생했을 때 에러메시지를 기록
      - 객체를 닫을 때 현재 스택에 있는 객체와 닫으려는 객체의 자료형이 다를 때
      (예: 스택 최상단에 객체가 있지만 배열을 닫는 ']' 토큰이 입력됨)
      (관련 메서드: rules.object.objectClose / rules.array.arrayClose)
      - 문자열 처리가 종료되었는데도 스택에 남아있는 객체가 있을 때
    * 에러메시지와 함께, 오류 발생 시 스택 최상단에 있던 객체를 함께 출력해 사용자의 에러 추적을 돕는다.
  2. 콜론이 없는 객체 표현식
    * 스택에 새로 객체/배열 객체를 생성하기 전, 현재 스택 최상단에 'objectProperty' 대신 'object'가 존재한다면 오류 메시지를 출력한다
      - 콜론이 입력되면서 'objectProperty'를 스택에 생성하기 때문에, 해당 객체가 스택에 없다면 현재 처리하는 객체 속성이 콜론 없이 입력되는 중임을 알 수 있다. 
      (관련 메서드: rules.object.objectOpen / rules.array.arrayOpen)
    * 객체를 닫을 때, 해당 객체가 가진 자녀 객체 중 키가 없는 자녀가 있다면 오류 메시지를 출력한다.
  3. (추가 규칙) 객체 키로 객체/배열 자료형이 사용된 경우
    * 객체의 속성 자료구조를 만드는 토큰 ':'이 입력될 때, 메모리에서 키로 사용할 자료를 불러올 때 자료형을 확인한다. 
    * 만약 해당 자료형이 객체/배열이라면 오류를 출력한다.
    (관련 메서드: rules.object.appendObjKey)


### 6. 프로그램 종료