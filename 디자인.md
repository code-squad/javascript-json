기존의 방식은 다양한 요소들의 타입을 고려하지 못한다.  
lexer를 만들어 타입을 구분하고, 스텍을 이용해 만들어보자.

# 디자인
- 먼저 '['는 그냥 스텍에 쌓고, 값은 자료형태의 객체로 만들어 쌓아준다.
stack ||| [, {...}, [, {...}, {...}, [                      <---   {...}   <---   112233

- 그러다 ']'를 만나면 '['가 나올때까지 전부 빼준다.
stack ||| [, {...}, [, {...}, {...}, [                      <---     ]
stack ||| [, {...}, [, {...}, {...}                         --->     [, {...}, ]

- 드리고 객체레 묶어준후 다시 스텍에 계속 쌓아준다.
stack ||| [, {...}, [, {...}, {...}                         <---   {자료구조}   <---   [, {...}, ]

- 이 프로세스를 stack안의 요소들이 전부 묶일때까지 반복해준다.
stack ||| {자료구조}

# 설계
먼저 문자로 들어온 배열을 각각의 토큰들로 나눌 필요가 있다.
```
const stack = [] // stack이 쌓일 배열을 만들자.
tokenizer(string){
    // 문자로 들어온 배열을 각각의 토큰으로 나누어 배열로 반환하자.
    return array;
}
lexer(token){
    // 토큰이 들어오면 type을 구분하여 반환하자.
    return [type, token];
}
parser(type, token){
    // 토큰과 그 타입이 들어오면 자료형태로 바꾸어 반환하자.
    return {type : type, value: token, child : []};
}
run(array){
    // tokenizer한 배열이 들어오면 하나씩 빼서 lexer와 parser를 이용해 stack에 쌓고 빼는 작업을 해주자. (아마 재귀로 구현될것 같음.)
    // 그리고 stack의 요소들이 모두 합쳐지면 그것을 반환하도록 하자.
    if(typeof stack[0] === 'object') return stack[0];
    const token = array.pop();
    [type, token] = lexer(token);
    const _stack = parser(type, token);
    stack.push(_stack);
    return array
}