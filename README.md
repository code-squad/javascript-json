# Array Parser

## STEP1. Array 데이터 분석

## 요구사항

* ArrayParser함수를 만든다.
* 배열안에는 숫자데이터만 존재한다.
* 배열형태의 문자열을 token단위로 해석한 후, 이를 분석한 자료구조를 만든다.
* 정규표현식 사용은 최소한으로 한다.(token의 타입체크에 한해 사용가능)

## 실행결과

```
`var str = "[123, 22, 33]";var result = ArrayParser(str);console.log(JSON.stringify(result, null, 2));`
```

## STEP2. 2중 중첩 배열 분석

## 요구사항

* 배열안에 배열이 있는 경우도 분석한다.

> var s = "[123,[22],33]";

* 중첩된 배열 원소도 역시, 숫자데이터만 존재한다.
* 중첩된 결과는 child 부분에 추가해서 결과가 표현돼야 한다.

* * *

## 실행결과

```
`var str = var s = "[123,[22],33, [1,2,3,4,5]]";var result = ArrayParser(str);console.log(JSON.stringify(result, null, 2));`
`*//배열안의 배열 같은경우, 다음과 같이 표현될 수 있다(예시)*
     { type: 'array', value: ArrayObject, child: [{type:'number', value:22, child:[]}] }`
```

## STEP3. 무한 중첩된 배열구조

## 요구사항

* 무한중첩 구조도 동작하게 한다. [[[[[]]]]]
* 배열의 원소에는 숫자타입만 존재한다.
* 복잡한 세부로직은 함수로 분리해본다.
* 중복된 코드역시 함수로 분리해서 일반화한다.
* 프로그래밍 설계를 같이 PR한다.
* hint : 중첩문제를 풀기 위해 stack구조를 활용해서 구현할 수도 있다.

* * *

## 실행결과

```
`var str = "[123,[22,23,[11,[112233],112],55],33]";var result = ArrayParser(str);console.log(JSON.stringify(result, null, 2));
*//중첩된 배열을 분석했음으로, 결과 역시 중첩된 객체형태이다.*`
```



# 설계

1. 일시적으로 요소를 저장하는 tmp 와 그룹화한 새로운 배열을 저장할 newList 선언
2. 배열의 시작과 끝을 파악하기 위해 calcArrBrackets 변수를 만들고, 해당 변수에 '['을 만나면 +1, ']'를 만나면 -1을 처리해서 합이 0이 되었을 때 해당 배열이 끝난 것으로 판단
3. 토큰 리스트를 순환
    1. token이 ','일 경우 tmp가 있을 때 tmp를 새로운 배열에 추가하고 tmp데이터 비운다.
    2. token이 ']'이고, 종료된 배열이면 tmp에 token 추가 후, 새로운 배열에 tmp 데이터 추가, tmp 데이터 비운다.
    3. 그 외 상황일 경우 tmp에 token을 추가
        1. token이 '['일 경우 배열 시작 상황 추가
        2. token이 ']'일 경우 배열 종료 상황 추가
4. 분석을 마친 토큰 데이터들을 원하는 데이터 형태로 파싱
    1. 파싱 중 배열 데이터를 만난 경우 3번의 작업으로 돌아가서 반복
    2. 숫자 데이터의 경우 파싱을 끝내고 객체 추가
